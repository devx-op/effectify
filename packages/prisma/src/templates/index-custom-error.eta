// This file was generated by prisma-effect-generator, do not edit manually.

import { Context, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "<%= it.clientImportPath %>"
import { <%= it.customError.className %>, mapPrismaError } from "<%= it.customError.path %>"
import * as Model from "./prisma-repository.js"

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

// Re-export the custom error type for convenience
export { <%= it.customError.className %> }

// Use the user-provided error mapper
const mapError = mapPrismaError

/**
 * Internal helper to begin a callback-free interactive transaction.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, <%= it.customError.className %>> =>
  Effect.async<FlatTransactionClient, <%= it.customError.className %>>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      if (e === ROLLBACK) return
      throw e
    })

    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | <%= it.customError.className %>, R> => {
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | <%= it.customError.className %>, R> => {
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      <%~ it.rawSqlOperations %>
    }
  })
}) {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

export const PrismaClientService = PrismaClient
export const PrismaService = Prisma
export const makePrismaLayer = PrismaClient.layer
export const makePrismaLayerEffect = PrismaClient.layerEffect

<%~ it.modelExports %>

