// This file was generated by prisma-effect-generator, do not edit manually.

import { Context, Data, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "<%= it.clientImportPath %>"
import * as Model from "./prisma-repository.js"
import { <%= it.schemaImports %> } from "./schemas/index.js"

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

/**
 * Internal helper to begin a callback-free interactive transaction.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, PrismaError> =>
  Effect.async<FlatTransactionClient, PrismaError>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      if (e === ROLLBACK) return
      throw e
    })

    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | PrismaError, R> => {
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | PrismaError, R> => {
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      <%~ it.rawSqlOperations %>
    }
  })
}) {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

export const PrismaClientService = PrismaClient
export const PrismaService = Prisma
export const makePrismaLayer = PrismaClient.layer
export const makePrismaLayerEffect = PrismaClient.layerEffect

<% it.models.forEach(function(model) { %>
export class <%= model.name %>Model extends Model.Class<<%= model.name %>Model>("<%= model.name %>")({
  ..._<%= model.name %>.fields
}) {}
<% }) %>
