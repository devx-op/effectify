#!/usr/bin/env tsx

import { execSync } from 'node:child_process'
import fs from 'node:fs/promises'
import path from 'node:path'
import gh from '@prisma/generator-helper'

const header = `-- This file was generated by sql-schema-generator, do not edit manually.
-- Generated at: ${new Date().toISOString()}

`

// Types for generator options
interface SqlGeneratorOptions {
  generator: {
    output?: {
      value: string
    }
  }
}

// Export the generator function for use in CLI
export async function generateSqlSchema(options: SqlGeneratorOptions) {
  const outputDir = options.generator.output?.value || '../generated'
  const datasourceUrl = 'prisma/dev.db'

  if (!datasourceUrl) {
    throw new Error('No datasource URL found')
  }

  // Ensure output directory exists
  await fs.mkdir(outputDir, { recursive: true })

  try {
    // Extract the database path from the URL (assuming sqlite)
    let dbPath = datasourceUrl
    if (dbPath.startsWith('file:')) {
      dbPath = dbPath.replace('file:', '')
    }

    // Make path relative to current working directory if needed
    if (!path.isAbsolute(dbPath)) {
      dbPath = path.resolve(process.cwd(), dbPath)
    }

    // Use sqlite3 to dump only the schema (no data)
    const schemaOutput = execSync(`sqlite3 "${dbPath}" ".schema"`, { encoding: 'utf8' })

    // Write the schema to the output file
    const outputPath = path.join(outputDir, 'schema.sql')
    await fs.writeFile(outputPath, header + schemaOutput)
  } catch (error) {
    console.error('‚ùå Failed to generate schema dump:', error.message)
    throw error
  }
}

gh.generatorHandler({
  onManifest() {
    return {
      defaultOutput: '../generated',
      prettyName: 'SQL Schema Generator',
      requiresEngines: [],
    }
  },

  async onGenerate(options) {
    await generateSqlSchema(options)
  },
})
