#!/usr/bin/env tsx

import fs from 'node:fs/promises'
import path from 'node:path'
import gh from '@prisma/generator-helper'

const header = '// This file was generated by prisma-effect-generator, do not edit manually.\n'

// Utility function to convert PascalCase to camelCase
function toCamelCase(str) {
  return str.charAt(0).toLowerCase() + str.slice(1)
}

// Types for generator options
interface GeneratorOptions {
  dmmf: {
    datamodel: {
      models: Array<{
        name: string
        fields: Array<{
          name: string
          type: string
        }>
      }>
    }
  }
  generator: {
    output?: {
      value: string
    }
  }
}

// Export the generator function for use in CLI
export async function generateEffectPrisma(options: GeneratorOptions) {
  const models = options.dmmf.datamodel.models
  const outputDir = options.generator.output?.value

  if (!outputDir) {
    throw new Error('No output directory specified')
  }

  // Clean output directory
  await fs.rm(outputDir, { recursive: true, force: true })
  await fs.mkdir(outputDir, { recursive: true })

  // Generate unified index file with PrismaService
  await generateUnifiedService([...models], outputDir)

  // Generate types file
  await generateTypes([...models], outputDir)
}

gh.generatorHandler({
  onManifest() {
    return {
      defaultOutput: '../src/generated/effect-prisma',
      prettyName: 'Prisma Effect Generator',
      requiresEngines: ['queryEngine'],
    }
  },

  async onGenerate(options) {
    await generateEffectPrisma(options)
  },
})

function generateErrorTypes(models) {
  const modelNames = models.map((model) => `"${model.name}"`).join(' | ')
  const operationNames = [
    '"findMany"',
    '"findUnique"',
    '"findFirst"',
    '"findUniqueOrThrow"',
    '"findFirstOrThrow"',
    '"create"',
    '"createMany"',
    '"createManyAndReturn"',
    '"update"',
    '"updateMany"',
    '"upsert"',
    '"delete"',
    '"deleteMany"',
    '"count"',
    '"aggregate"',
    '"groupBy"',
    '"$executeRaw"',
    '"$executeRawUnsafe"',
    '"$queryRaw"',
    '"$queryRawUnsafe"',
  ].join(' | ')

  return `
// String literal types for exhaustive error handling
export type ModelName = ${modelNames} 
export type OperationName = ${operationNames}

// Specific Prisma error types for exhaustive error handling
export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFound")<{
  model: ModelName | "Prisma"
  operation: OperationName
  where?: unknown
}> {}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraint")<{
  model: ModelName | "Prisma"
  operation: OperationName
  field?: string
  value?: unknown
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraint")<{
  model: ModelName | "Prisma"
  operation: OperationName
  field?: string
  referencedModel?: string
}> {}

export class PrismaRequiredFieldError extends Data.TaggedError("PrismaRequiredField")<{
  model: ModelName | "Prisma"
  operation: OperationName
  field: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnection")<{
  model: ModelName | "Prisma"
  operation: OperationName
  message?: string
}> {}

export class PrismaValidationError extends Data.TaggedError("PrismaValidation")<{
  model: ModelName | "Prisma"
  operation: OperationName
  message: string
}> {}

export class PrismaUnknownError extends Data.TaggedError("PrismaUnknown")<{
  model: ModelName | "Prisma"
  operation: OperationName
  originalError: unknown
}> {}

// Error conversion function
function convertPrismaError(error: unknown, model: ModelName | "Prisma", operation: OperationName): 
  | PrismaRecordNotFoundError 
  | PrismaUniqueConstraintError 
  | PrismaForeignKeyConstraintError 
  | PrismaRequiredFieldError 
  | PrismaConnectionError 
  | PrismaValidationError 
  | PrismaUnknownError {
  
  // Handle Prisma-specific errors
  if (error && typeof error === 'object') {
    const prismaError = error as any
    
    // PrismaClientKnownRequestError
    if (prismaError.code) {
      switch (prismaError.code) {
        case 'P2002': // Unique constraint violation
          return new PrismaUniqueConstraintError({
            model,
            operation,
            field: prismaError.meta?.target?.[0] as string,
            value: prismaError.meta?.value
          })
        
        case 'P2025': // Record not found
        case 'P2016': // Query interpretation error (record not found)
          return new PrismaRecordNotFoundError({
            model,
            operation,
            where: prismaError.meta
          })
        
        case 'P2003': // Foreign key constraint violation
        case 'P2014': // Required relation violation
          return new PrismaForeignKeyConstraintError({
            model,
            operation,
            field: prismaError.meta?.field_name as string,
            referencedModel: prismaError.meta?.model_name as string
          })
        
        case 'P2012': // Missing required field
        case 'P2011': // Null constraint violation
          return new PrismaRequiredFieldError({
            model,
            operation,
            field: prismaError.meta?.field as string
          })
        
        case 'P1000': // Authentication failed
        case 'P1001': // Can't reach database server
        case 'P1002': // Database server timeout
        case 'P1008': // Operations timed out
          return new PrismaConnectionError({
            model,
            operation,
            message: prismaError.message as string
          })
      }
    }
    
    // PrismaClientValidationError
    if (prismaError.name === 'PrismaClientValidationError') {
      return new PrismaValidationError({
        model,
        operation,
        message: prismaError.message as string
      })
    }
    
    // PrismaClientInitializationError
    if (prismaError.name === 'PrismaClientInitializationError') {
      return new PrismaConnectionError({
        model,
        operation,
        message: prismaError.message as string
      })
    }
  }
  
  // Fallback to unknown error
  return new PrismaUnknownError({
    model,
    operation,
    originalError: error
  })
}`
}

function generateErrorUnionTypes(models) {
  return models
    .map((model) => {
      const modelName = model.name
      return `
// Error unions for ${modelName}
export type ${modelName}FindErrors = PrismaConnectionError | PrismaUnknownError
export type ${modelName}FindOrThrowErrors = PrismaRecordNotFoundError | PrismaConnectionError | PrismaUnknownError
export type ${modelName}CreateErrors = PrismaUniqueConstraintError | PrismaForeignKeyConstraintError | PrismaRequiredFieldError | PrismaValidationError | PrismaConnectionError | PrismaUnknownError
export type ${modelName}UpdateErrors = PrismaRecordNotFoundError | PrismaUniqueConstraintError | PrismaForeignKeyConstraintError | PrismaValidationError | PrismaConnectionError | PrismaUnknownError
export type ${modelName}UpsertErrors = PrismaUniqueConstraintError | PrismaForeignKeyConstraintError | PrismaRequiredFieldError | PrismaValidationError | PrismaConnectionError | PrismaUnknownError
export type ${modelName}DeleteErrors = PrismaRecordNotFoundError | PrismaForeignKeyConstraintError | PrismaConnectionError | PrismaUnknownError
export type ${modelName}AggregateErrors = PrismaConnectionError | PrismaValidationError | PrismaUnknownError`
    })
    .join('\n')
}

function generateRawSqlOperations() {
  return `      
  // eslint-disable-next-line @typescript-eslint/array-type
      $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => convertPrismaError(error, "Prisma", "$executeRaw")
        }),

  // eslint-disable-next-line @typescript-eslint/array-type
      $executeRawUnsafe: (query: string, ...values: any[]) =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => convertPrismaError(error, "Prisma", "$executeRawUnsafe")
        }),

    // eslint-disable-next-line @typescript-eslint/array-type
      $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
          catch: (error) => convertPrismaError(error, "Prisma", "$queryRaw")
        }),

    // eslint-disable-next-line @typescript-eslint/array-type
      $queryRawUnsafe: (query: string, ...values: any[]) =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values),
          catch: (error) => convertPrismaError(error, "Prisma", "$queryRawUnsafe")
        }),`
}

function generateModelOperations(models) {
  return models
    .map((model) => {
      const modelName = model.name
      const modelNameCamel = toCamelCase(modelName)

      return `      ${modelNameCamel}: {
        // Find operations
        findMany: (args?: Prisma.${modelName}FindManyArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findMany(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "findMany")
          }),

        findUnique: (args: Prisma.${modelName}FindUniqueArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUnique(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "findUnique")
          }),

        findFirst: (args?: Prisma.${modelName}FindFirstArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirst(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "findFirst")
          }),

        findUniqueOrThrow: (args: Prisma.${modelName}FindUniqueOrThrowArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findUniqueOrThrow(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "findUniqueOrThrow")
          }),

        findFirstOrThrow: (args?: Prisma.${modelName}FindFirstOrThrowArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.findFirstOrThrow(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "findFirstOrThrow")
          }),

        // Create operations
        create: (args: Prisma.${modelName}CreateArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.create(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "create")
          }),

        createMany: (args: Prisma.${modelName}CreateManyArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createMany(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "createMany")
          }),

        createManyAndReturn: (args: Prisma.${modelName}CreateManyAndReturnArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.createManyAndReturn(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "createManyAndReturn")
          }),

        // Update operations
        update: (args: Prisma.${modelName}UpdateArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.update(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "update")
          }),

        updateMany: (args: Prisma.${modelName}UpdateManyArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.updateMany(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "updateMany")
          }),

        upsert: (args: Prisma.${modelName}UpsertArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.upsert(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "upsert")
          }),

        // Delete operations
        delete: (args: Prisma.${modelName}DeleteArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.delete(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "delete")
          }),

        deleteMany: (args?: Prisma.${modelName}DeleteManyArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.deleteMany(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "deleteMany")
          }),

        // Aggregate operations
        count: (args?: Prisma.${modelName}CountArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.count(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "count")
          }),

        aggregate: (args: Prisma.${modelName}AggregateArgs) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.aggregate(args),
            catch: (error) => convertPrismaError(error, "${modelName}", "aggregate")
          }),

        groupBy: <T extends Prisma.${modelName}GroupByArgs>(args: T) =>
          Effect.tryPromise({
            try: () => client.${modelNameCamel}.groupBy(args as any),
            catch: (error) => convertPrismaError(error, "${modelName}", "groupBy")
          })
      }`
    })
    .join(',\n\n')
}

async function generateUnifiedService(models, outputDir) {
  const errorTypes = generateErrorTypes(models)
  const errorUnions = generateErrorUnionTypes(models)
  const rawSqlOperations = generateRawSqlOperations()
  const modelOperations = generateModelOperations(models)

  const serviceContent = `${header}
import { Context, Data, Effect, Layer } from "effect"
import { Service } from "effect/Effect"
import { type Prisma, PrismaClient } from "../prisma/index.js"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  {
    tx: PrismaClient | Prisma.TransactionClient
    client: PrismaClient
  }
>() {}

export const LivePrismaLayer = Layer.effect(
  PrismaClientService,
  Effect.sync(() => {
    const prisma = new PrismaClient()
    return {
      // The \`tx\` property (transaction) can be shared and overridden,
      // but the \`client\` property must always be a PrismaClient instance.
      tx: prisma,
      client: prisma
    }
  })
)

${errorTypes}

${errorUnions}

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    const { tx: client } = yield* PrismaClientService
    return {
${rawSqlOperations}

${modelOperations}
    }
  })
}) {}
`

  await fs.writeFile(path.join(outputDir, 'index.ts'), serviceContent)
}

async function generateTypes(models, outputDir) {
  const modelTypeDefinitions = models
    .map((model) => {
      const modelName = model.name
      const modelNameCamel = toCamelCase(modelName)

      return `    ${modelNameCamel}: {
      findMany: (args?: Prisma.${modelName}FindManyArgs) => Effect.Effect<Array<${modelName}>, ${modelName}FindErrors>
      findUnique: (args: Prisma.${modelName}FindUniqueArgs) => Effect.Effect<${modelName} | null, ${modelName}FindErrors>
      findFirst: (args?: Prisma.${modelName}FindFirstArgs) => Effect.Effect<${modelName} | null, ${modelName}FindErrors>
      findUniqueOrThrow: (args: Prisma.${modelName}FindUniqueOrThrowArgs) => Effect.Effect<${modelName}, ${modelName}FindOrThrowErrors>
      findFirstOrThrow: (args?: Prisma.${modelName}FindFirstOrThrowArgs) => Effect.Effect<${modelName}, ${modelName}FindOrThrowErrors>
      create: (args: Prisma.${modelName}CreateArgs) => Effect.Effect<${modelName}, ${modelName}CreateErrors>
      createMany: (args: Prisma.${modelName}CreateManyArgs) => Effect.Effect<Prisma.BatchPayload, ${modelName}CreateErrors>
      createManyAndReturn: (args: Prisma.${modelName}CreateManyAndReturnArgs) => Effect.Effect<Array<${modelName}>, ${modelName}CreateErrors>
      update: (args: Prisma.${modelName}UpdateArgs) => Effect.Effect<${modelName}, ${modelName}UpdateErrors>
      updateMany: (args: Prisma.${modelName}UpdateManyArgs) => Effect.Effect<Prisma.BatchPayload, ${modelName}UpdateErrors>
      upsert: (args: Prisma.${modelName}UpsertArgs) => Effect.Effect<${modelName}, ${modelName}UpsertErrors>
      delete: (args: Prisma.${modelName}DeleteArgs) => Effect.Effect<${modelName}, ${modelName}DeleteErrors>
      deleteMany: (args?: Prisma.${modelName}DeleteManyArgs) => Effect.Effect<Prisma.BatchPayload, ${modelName}DeleteErrors>
      count: (args?: Prisma.${modelName}CountArgs) => Effect.Effect<number, ${modelName}AggregateErrors>
      aggregate: (args: Prisma.${modelName}AggregateArgs) => Effect.Effect<any, ${modelName}AggregateErrors>
      groupBy: <T extends Prisma.${modelName}GroupByArgs>(args: T) => Effect.Effect<any, ${modelName}AggregateErrors>
    }`
    })
    .join('\n')

  const rawSqlErrorType = 'PrismaConnectionError | PrismaValidationError | PrismaUnknownError'

  const typeContent = `${header}
import type { Effect } from "effect"
import type { Prisma } from "../prisma/index.js"
import type { 
  ModelName,
  OperationName,
  PrismaRecordNotFoundError,
  PrismaUniqueConstraintError,
  PrismaForeignKeyConstraintError,
  PrismaRequiredFieldError,
  PrismaConnectionError,
  PrismaValidationError,
  PrismaUnknownError,
${models.map((model) => `  ${model.name}FindErrors,\n  ${model.name}FindOrThrowErrors,\n  ${model.name}CreateErrors,\n  ${model.name}UpdateErrors,\n  ${model.name}UpsertErrors,\n  ${model.name}DeleteErrors,\n  ${model.name}AggregateErrors`).join(',\n')}
} from "./index.js"

export type EffectPrismaService = {
  // eslint-disable-next-line @typescript-eslint/array-type
  $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) => Effect.Effect<number, ${rawSqlErrorType}>
  // eslint-disable-next-line @typescript-eslint/array-type
  $executeRawUnsafe: (query: string, ...values: any[]) => Effect.Effect<number, ${rawSqlErrorType}>
  // eslint-disable-next-line @typescript-eslint/array-type
  $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) => Effect.Effect<unknown, ${rawSqlErrorType}>
  // eslint-disable-next-line @typescript-eslint/array-type
  $queryRawUnsafe: (query: string, ...values: any[]) => Effect.Effect<unknown, ${rawSqlErrorType}>
${modelTypeDefinitions}
}

// Individual model types
${models
  .map(
    (model) => `

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
  export type ${model.name} = Prisma.${model.name}GetPayload<{}>
  `,
  )
  .join('\n')}
`

  await fs.writeFile(path.join(outputDir, 'types.ts'), typeContent)
}
