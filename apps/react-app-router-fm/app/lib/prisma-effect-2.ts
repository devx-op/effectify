#!/usr/bin/env node
/** biome-ignore-all lint/nursery/useMaxParams: <explanation> */
/** biome-ignore-all lint/nursery/noShadow: <todo> */
/** biome-ignore-all lint/complexity/noExcessiveCognitiveComplexity: <todo> */
import fs from 'node:fs/promises'
import path from 'node:path'
import type { DMMF } from '@prisma/client/runtime/client.js'
import type { GeneratorOptions } from '@prisma/generator'
import generatorHelper from '@prisma/generator-helper'

const { generatorHandler } = generatorHelper

const header = '// This file was generated by prisma-effect-generator, do not edit manually.\n'

// Utility function to convert PascalCase to camelCase
function _toCamelCase(str: string) {
  return str.charAt(0).toLowerCase() + str.slice(1)
}

const prismaSchemaContent = `/**
 * @since 1.0.0
 */
import * as Cause from 'effect/Cause'
import * as Effect from 'effect/Effect'
import type * as Option from 'effect/Option'
import type { ParseError } from 'effect/ParseResult'
import * as Schema from 'effect/Schema'

/**
 * Run a sql query with a request schema and a result schema.
 *
 * @since 1.0.0
 * @category constructor
 */
export const findAll = <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => {
  const encodeRequest = Schema.encode(options.Request)
  const decode = Schema.decodeUnknown(Schema.Array(options.Result))
  return (request: IA): Effect.Effect<ReadonlyArray<A>, E | ParseError, R | IR | AR> =>
    Effect.flatMap(Effect.flatMap(encodeRequest(request), options.execute), decode)
}

const void_ = <IR, II, IA, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly execute: (request: II) => Effect.Effect<unknown, E, R>
}) => {
  const encode = Schema.encode(options.Request)
  return (request: IA): Effect.Effect<void, E | ParseError, R | IR> =>
    Effect.asVoid(Effect.flatMap(encode(request), options.execute))
}
export {
  /**
   * Run a sql query with a request schema and discard the result.
   *
   * @since 1.0.0
   * @category constructor
   */
  void_ as void,
}

/**
 * Run a sql query with a request schema and a result schema and return the first result.
 *
 * @since 1.0.0
 * @category constructor
 */
export const findOne = <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => {
  const encodeRequest = Schema.encode(options.Request)
  const decode = Schema.decodeUnknown(options.Result)
  return (request: IA): Effect.Effect<Option.Option<A>, E | ParseError, R | IR | AR> =>
    Effect.flatMap(Effect.flatMap(encodeRequest(request), options.execute), (arr) =>
      Array.isArray(arr) && arr.length > 0 ? Effect.asSome(decode(arr[0])) : Effect.succeedNone,
    )
}

/**
 * Run a sql query with a request schema and a result schema and return the first result.
 *
 * @since 1.0.0
 * @category constructor
 */
export const single = <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => {
  const encodeRequest = Schema.encode(options.Request)
  const decode = Schema.decodeUnknown(options.Result)
  return (request: IA): Effect.Effect<A, E | ParseError | Cause.NoSuchElementException, R | IR | AR> =>
    Effect.flatMap(
      Effect.flatMap(encodeRequest(request), options.execute),
      (arr): Effect.Effect<A, ParseError | Cause.NoSuchElementException, AR> =>
        Array.isArray(arr) && arr.length > 0 ? decode(arr[0]) : Effect.fail(new Cause.NoSuchElementException()),
    )
}

export const many = <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<Array<unknown>, E, R>
}) => {
  const encodeRequest = Schema.encode(options.Request)
  const decode = Schema.decodeUnknown(Schema.Array(options.Result))
  return (request: IA): Effect.Effect<Array<A>, E | ParseError, R | IR | AR> =>
    Effect.map(Effect.flatMap(Effect.flatMap(encodeRequest(request), options.execute), decode), (arr) => [...arr])
}
`

const getPrismaModelContent = (
  clientImportPath: string,
) => `/** biome-ignore-all lint/suspicious/noExplicitAny: <todo> */
/** biome-ignore-all lint/style/useDefaultSwitchClause: <todo> */

import * as VariantSchema from '@effect/experimental/VariantSchema'
import { type PrismaClient as BasePrismaClient, Prisma as PrismaNamespace } from '${clientImportPath}'
import { PrismaClient } from './index.js'
import * as Data from 'effect/Data'
import * as Effect from 'effect/Effect'
import type * as Option from 'effect/Option'
import * as Schema from 'effect/Schema'
import * as SqlSchema from './prisma-schema.js'

export class PrismaUniqueConstraintError extends Data.TaggedError('PrismaUniqueConstraintError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError('PrismaForeignKeyConstraintError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError('PrismaRecordNotFoundError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError('PrismaRelationViolationError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError('PrismaRelatedRecordNotFoundError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError('PrismaTransactionConflictError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError('PrismaValueTooLongError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError('PrismaValueOutOfRangeError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError('PrismaDbConstraintError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError('PrismaConnectionError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError('PrismaMissingRequiredValueError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError('PrismaInputValidationError')<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

// Create, Upsert
export const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2000':
        return new PrismaValueTooLongError({ cause: error, operation, model })
      case 'P2002':
        return new PrismaUniqueConstraintError({ cause: error, operation, model })
      case 'P2003':
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model })
      case 'P2004':
        return new PrismaDbConstraintError({ cause: error, operation, model })
      case 'P2005':
      case 'P2006':
      case 'P2019':
        return new PrismaInputValidationError({ cause: error, operation, model })
      case 'P2011':
      case 'P2012':
        return new PrismaMissingRequiredValueError({ cause: error, operation, model })
      case 'P2015':
      case 'P2018':
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model })
      case 'P2020':
        return new PrismaValueOutOfRangeError({ cause: error, operation, model })
      case 'P2024':
        return new PrismaConnectionError({ cause: error, operation, model })
      case 'P2034':
        return new PrismaTransactionConflictError({ cause: error, operation, model })
    }
  }
  throw error
}

// Update
export const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
export const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
export const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
export const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
export const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
export const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

const { Class, Field, FieldExcept, FieldOnly, Struct, Union, extract, fieldEvolve, fieldFromKey } = VariantSchema.make({
  variants: [
    'findUnique',
    'findUniqueOrThrow',
    'findFirst',
    'findFirstOrThrow',
    'findMany',
    'create',
    'createMany',
    'createManyAndReturn',
    'update',
    'json',
    'jsonCreate',
    'jsonUpdate',
  ],
  defaultVariant: 'findUnique',
})

/**
 * @since 1.0.0
 * @category models
 */
export type Any = Schema.Schema.Any & {
  readonly fields: Schema.Struct.Fields
  readonly findUnique: Schema.Schema.Any
  readonly findUniqueOrThrow: Schema.Schema.Any
  readonly findFirst: Schema.Schema.Any
  readonly findFirstOrThrow: Schema.Schema.Any
  readonly findMany: Schema.Schema.Any
  readonly create: Schema.Schema.Any
  readonly createMany: Schema.Schema.Any
  readonly createManyAndReturn: Schema.Schema.Any
  readonly update: Schema.Schema.Any
  readonly json: Schema.Schema.Any
  readonly jsonCreate: Schema.Schema.Any
  readonly jsonUpdate: Schema.Schema.Any
}

/**
 * @since 1.0.0
 * @category models
 */
export type AnyNoContext = Schema.Schema.AnyNoContext & {
  readonly fields: Schema.Struct.Fields
  readonly findUnique: Schema.Schema.AnyNoContext
  readonly findUniqueOrThrow: Schema.Schema.AnyNoContext
  readonly findFirst: Schema.Schema.AnyNoContext
  readonly findFirstOrThrow: Schema.Schema.AnyNoContext
  readonly findMany: Schema.Schema.AnyNoContext
  readonly create: Schema.Schema.AnyNoContext
  readonly createMany: Schema.Schema.AnyNoContext
  readonly createManyAndReturn: Schema.Schema.AnyNoContext
  readonly update: Schema.Schema.AnyNoContext
  readonly json: Schema.Schema.AnyNoContext
  readonly jsonCreate: Schema.Schema.AnyNoContext
  readonly jsonUpdate: Schema.Schema.AnyNoContext
}

/**
 * @since 1.0.0
 * @category models
 */
export type VariantsDatabase =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'findMany'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'

/**
 * @since 1.0.0
 * @category models
 */
export type VariantsJson = 'json' | 'jsonCreate' | 'jsonUpdate'

export {
  /**
   * A base class used for creating domain model schemas.
   *
   * It supports common variants for database and JSON apis.
   *
   * @since 1.0.0
   * @category constructors
   * @example
   * \`\`\`ts
   * import { Schema } from "effect"
   * import { Model } from "@effect/sql"
   *
   * export const GroupId = Schema.Number.pipe(Schema.brand("GroupId"))
   *
   * export class Group extends Model.Class<Group>("Group")({
   *   id: Model.Generated(GroupId),
   *   name: Schema.NonEmptyTrimmedString,
   *   createdAt: Model.DateTimeInsertFromDate,
   *   updatedAt: Model.DateTimeUpdateFromDate
   * }) {}
   *
   * // schema used for selects
   * Group
   *
   * // schema used for inserts
   * Group.insert
   *
   * // schema used for updates
   * Group.update
   *
   * // schema used for json api
   * Group.json
   * Group.jsonCreate
   * Group.jsonUpdate
   *
   * // you can also turn them into classes
   * class GroupJson extends Schema.Class<GroupJson>("GroupJson")(Group.json) {
   *   get upperName() {
   *     return this.name.toUpperCase()
   *   }
   * }
   * \`\`\`
   */
  Class,
  /**
   * @since 1.0.0
   * @category extraction
   */
  extract,
  /**
   * @since 1.0.0
   * @category fields
   */
  Field,
  /**
   * @since 1.0.0
   * @category fields
   */
  fieldEvolve,
  /**
   * @since 1.0.0
   * @category fields
   */
  FieldExcept,
  /**
   * @since 1.0.0
   * @category fields
   */
  fieldFromKey,
  /**
   * @since 1.0.0
   * @category fields
   */
  FieldOnly,
  /**
   * @since 1.0.0
   * @category constructors
   */
  Struct,
  /**
   * @since 1.0.0
   * @category constructors
   */
  Union,
}

/**
 * Create a simple CRUD repository from a model.
 *
 * @since 1.0.0
 * @category repository
 */
export const make = <S extends Any, M extends keyof BasePrismaClient>(
  Model: S,
  options: {
    readonly modelName: M extends string ? M : string
    readonly spanPrefix: string
    readonly uniqueKey?: string | ReadonlyArray<string>
  },
): Effect.Effect<
  {
    readonly findUnique: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>,
    ) => Effect.Effect<Option.Option<S['Type']>, PrismaFindError, S['Context'] | S['findUnique']['Context']>

    readonly findUniqueOrThrow: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>,
    ) => Effect.Effect<S['Type'], PrismaFindOrThrowError, S['Context'] | S['findUniqueOrThrow']['Context']>

    readonly findFirst: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findFirst'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findFirst'>>
    ) => Effect.Effect<Option.Option<S['Type']>, PrismaFindError, S['Context'] | S['findFirst']['Context']>

    readonly findFirstOrThrow: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findFirstOrThrow'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findFirstOrThrow'>>
    ) => Effect.Effect<S['Type'], PrismaFindOrThrowError, S['Context'] | S['findFirstOrThrow']['Context']>

    readonly findMany: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findMany'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findMany'>>
    ) => Effect.Effect<Array<S['Type']>, PrismaFindError, S['Context'] | S['findMany']['Context']>

    readonly create: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'create'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'create'>>,
    ) => Effect.Effect<S['Type'], PrismaCreateError, S['Context'] | S['create']['Context']>

    readonly createMany: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'createMany'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'createMany'>>,
    ) => Effect.Effect<PrismaNamespace.BatchPayload, PrismaCreateError, S['Context'] | S['createMany']['Context']>

    readonly createManyAndReturn: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'createManyAndReturn'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'createManyAndReturn'>>,
    ) => Effect.Effect<Array<S['Type']>, PrismaCreateError, S['Context'] | S['createManyAndReturn']['Context']>

    readonly update: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'update'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'update'>>
    ) => Effect.Effect<S['Type'], PrismaUpdateError, S['Context'] | S['update']['Context']>

    readonly updateMany: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'updateMany'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'updateMany'>>
    ) => Effect.Effect<PrismaNamespace.BatchPayload, PrismaUpdateManyError, S['Context'] | S['update']['Context']>

    readonly delete: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'delete'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'delete'>>
    ) => Effect.Effect<S['Type'], PrismaDeleteError, S['Context']>

    readonly deleteMany: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'deleteMany'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'deleteMany'>>
    ) => Effect.Effect<PrismaNamespace.BatchPayload, PrismaDeleteManyError, S['Context']>

    readonly upsert: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'upsert'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'upsert'>>
    ) => Effect.Effect<S['Type'], PrismaCreateError, S['Context']>

    readonly count: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'count'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'count'>>
    ) => Effect.Effect<unknown, PrismaFindError, S['Context']>

    readonly aggregate: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'aggregate'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'aggregate'>>
    ) => Effect.Effect<unknown, PrismaFindError, S['Context']>

    readonly groupBy: <A extends PrismaNamespace.Args<BasePrismaClient[M], 'groupBy'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'groupBy'>>
    ) => Effect.Effect<unknown, PrismaFindError, S['Context']>
  },
  never,
  PrismaClient
> =>
  Effect.gen(function* () {
    const prisma = yield* PrismaClient

    // Construye el schema del where para findUnique usando uniqueKey en modo builder
    let findUniqueRequestSchema: Schema.Schema<any, any, any> = Schema.Unknown
    if (options.uniqueKey) {
      const keys = Array.isArray(options.uniqueKey) ? options.uniqueKey : [options.uniqueKey]
      const shape: Record<string, Schema.Schema.Any> = {}
      let valid = true
      for (const key of keys) {
        const field = (Model as any).fields?.[key]
        if (!field) {
          valid = false
          break
        }
        shape[key] = field
      }
      if (valid) {
        findUniqueRequestSchema = Schema.Struct(shape as any)
      }
    }

    const findUniqueSchema = SqlSchema.findOne({
      Request: findUniqueRequestSchema,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).findUnique({ where: request }) as any,
          catch: (error) => mapFindError(error, 'findUnique', options.modelName),
        }).pipe(Effect.map((result) => (result ? [result] : []))),
    })

    const findUnique = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>,
    ): Effect.Effect<Option.Option<S['Type']>, never, S['Context'] | S['findUnique']['Context']> =>
      findUniqueSchema((args as any).where).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.findUnique\`, {
          captureStackTrace: false,
          attributes: { ...(args as any).where },
        }),
      ) as any

    const findUniqueOrThrowSchema = SqlSchema.single({
      Request: findUniqueRequestSchema,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).findUniqueOrThrow({
              where: request,
            }) as any,
          catch: (error) => mapFindOrThrowError(error, 'findUniqueOrThrow', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const findUniqueOrThrow = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findUnique'>>,
    ): Effect.Effect<S['Type'], never, S['Context'] | S['findUniqueOrThrow']['Context']> =>
      findUniqueOrThrowSchema((args as any).where).pipe(
        Effect.map((result) => result as S['Type']),
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.findUniqueOrThrow\`, {
          captureStackTrace: false,
          attributes: { ...(args as any).where },
        }),
      ) as any

    const findFirstSchema = SqlSchema.findOne({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).findFirst(request) as any,
          catch: (error) => mapFindError(error, 'findFirst', options.modelName),
        }).pipe(Effect.map((result) => (result ? [result] : []))),
    })

    const findFirst = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findFirst'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findFirst'>>
    ): Effect.Effect<Option.Option<S['Type']>, never, S['Context'] | S['findFirst']['Context']> =>
      findFirstSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.findFirst\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const findFirstOrThrowSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).findFirstOrThrow(request) as any,
          catch: (error) => mapFindOrThrowError(error, 'findFirstOrThrow', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const findFirstOrThrow = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findFirstOrThrow'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findFirstOrThrow'>>
    ): Effect.Effect<S['Type'], never, S['Context'] | S['findFirstOrThrow']['Context']> =>
      findFirstOrThrowSchema(args).pipe(
        Effect.map((result) => result as S['Type']),
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.findFirstOrThrow\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const findManySchema = SqlSchema.many({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).findMany(request) as any,
          catch: (error) => mapFindError(error, 'findMany', options.modelName),
        }).pipe(Effect.map((result) => result as any)),
    })

    const findMany = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'findMany'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'findMany'>>
    ): Effect.Effect<Array<S['Type']>, never, S['Context'] | S['findMany']['Context']> =>
      findManySchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.findMany\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const createSchema = SqlSchema.single({
      Request: Model.create,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).create({ data: request }),
          catch: (error) => mapCreateError(error, 'create', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const create = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'create'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'create'>>,
    ): Effect.Effect<S['Type'], never, S['Context'] | S['create']['Context']> =>
      createSchema((args as any).data).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.create\`, {
          captureStackTrace: false,
          attributes: { ...(args as any).data },
        }),
      ) as any

    const createManySchema = SqlSchema.single({
      Request: Schema.Array(Model.createMany),
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).createMany({ data: request as any }),
          catch: (error) => mapCreateError(error, 'createMany', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const createMany = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'createMany'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'createMany'>>,
    ): Effect.Effect<PrismaNamespace.BatchPayload, never, S['Context'] | S['createMany']['Context']> =>
      createManySchema((args as any).data).pipe(
        Effect.map((res) => res as unknown as PrismaNamespace.BatchPayload),
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.createMany\`, {
          captureStackTrace: false,
          attributes: { ...(args as any).data },
        }),
      ) as any

    const createManyAndReturnSchema = SqlSchema.many({
      Request: Schema.Array(Model.createMany),
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () =>
            ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).createManyAndReturn({
              data: request as any,
            }),
          catch: (error) => mapCreateError(error, 'createManyAndReturn', options.modelName),
        }),
    })

    const createManyAndReturn = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'createManyAndReturn'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'createManyAndReturn'>>,
    ): Effect.Effect<Array<S['Type']>, never, S['Context'] | S['createManyAndReturn']['Context']> =>
      createManyAndReturnSchema((args as any).data).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.createManyAndReturn\`, {
          captureStackTrace: false,
          attributes: { ...(args as any).data },
        }),
      ) as any

    const countSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).count(request),
          catch: (error) => mapFindError(error, 'count', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const count = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'count'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'count'>>
    ): Effect.Effect<unknown, never, S['Context']> =>
      countSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.count\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const updateSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).update(request),
          catch: (error) => mapUpdateError(error, 'update', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const update = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'update'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'update'>>
    ): Effect.Effect<S['Type'], never, S['Context'] | S['update']['Context']> =>
      updateSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.update\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const deleteSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).delete(request),
          catch: (error) => mapDeleteError(error, 'delete', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const delete_ = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'delete'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'delete'>>
    ): Effect.Effect<S['Type'], never, S['Context']> =>
      deleteSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.delete\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const upsertSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Model,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).upsert(request),
          catch: (error) => mapCreateError(error, 'upsert', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const upsert = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'upsert'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'upsert'>>
    ): Effect.Effect<S['Type'], never, S['Context']> =>
      upsertSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.upsert\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const aggregateSchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).aggregate(request),
          catch: (error) => mapFindError(error, 'aggregate', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const aggregate = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'aggregate'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'aggregate'>>
    ): Effect.Effect<unknown, never, S['Context']> =>
      aggregateSchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.aggregate\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const groupBySchema = SqlSchema.many({
      Request: Schema.Unknown,
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).groupBy(request),
          catch: (error) => mapFindError(error, 'groupBy', options.modelName),
        }).pipe(Effect.map((result) => result as any)),
    })

    const groupBy = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'groupBy'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'groupBy'>>
    ): Effect.Effect<unknown, never, S['Context']> =>
      groupBySchema(args).pipe(
        Effect.catchTag('ParseError', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.groupBy\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const updateManySchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).updateMany(request),
          catch: (error) => mapUpdateManyError(error, 'updateMany', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const updateMany = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'updateMany'>>(
      args: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'updateMany'>>
    ): Effect.Effect<PrismaNamespace.BatchPayload, never, S['Context'] | S['update']['Context']> =>
      updateManySchema(args).pipe(
        Effect.map((res) => res as unknown as PrismaNamespace.BatchPayload),
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.updateMany\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    const deleteManySchema = SqlSchema.single({
      Request: Schema.Unknown,
      Result: Schema.Unknown,
      execute: (request) =>
        Effect.tryPromise({
          try: () => ((prisma.tx as BasePrismaClient)[options.modelName as M] as any).deleteMany(request),
          catch: (error) => mapDeleteManyError(error, 'deleteMany', options.modelName),
        }).pipe(Effect.map((result) => [result] as any)),
    })

    const deleteMany = <A extends PrismaNamespace.Args<BasePrismaClient[M], 'deleteMany'>>(
      args?: PrismaNamespace.Exact<A, PrismaNamespace.Args<BasePrismaClient[M], 'deleteMany'>>
    ): Effect.Effect<PrismaNamespace.BatchPayload, never, S['Context']> =>
      deleteManySchema(args).pipe(
        Effect.map((res) => res as unknown as PrismaNamespace.BatchPayload),
        Effect.catchTag('ParseError', Effect.die),
        Effect.catchTag('NoSuchElementException', Effect.die),
        Effect.withSpan(\`\${options.spanPrefix}.deleteMany\`, {
          captureStackTrace: false,
          attributes: { ...(args as any) },
        }),
      ) as any

    return {
      findUnique,
      findUniqueOrThrow,
      findFirst,
      findFirstOrThrow,
      findMany,
      create,
      createMany,
      createManyAndReturn,
      update,
      updateMany,
      delete: delete_,
      deleteMany,
      upsert,
      count,
      aggregate,
      groupBy
    } as const

  })
`

generatorHandler({
  onManifest() {
    return {
      defaultOutput: '../generated/effect',
      prettyName: 'Prisma Effect Generator',
      // No engines required - we only read the DMMF schema
      requiresEngines: [],
    }
  },

  async onGenerate(options: GeneratorOptions) {
    const models = options.dmmf.datamodel.models
    const outputDir = options.generator.output?.value
    const schemaDir = path.dirname(options.schemaPath)

    const configPath = options.generator.config.clientImportPath
    const clientImportPath = Array.isArray(configPath) ? configPath[0] : (configPath ?? '@prisma/client')

    const errorConfigRaw = options.generator.config.errorImportPath
    const errorImportPathRaw = Array.isArray(errorConfigRaw) ? errorConfigRaw[0] : errorConfigRaw

    const importExtConfigRaw = options.generator.config.importFileExtension
    const importFileExtension = Array.isArray(importExtConfigRaw) ? importExtConfigRaw[0] : (importExtConfigRaw ?? '')

    if (!outputDir) {
      throw new Error('No output directory specified')
    }

    const addExtension = (filePath: string): string => {
      if (!importFileExtension) {
        return filePath
      }
      const ext = path.extname(filePath)
      if (ext) {
        return filePath
      }
      return `${filePath}.${importFileExtension}`
    }

    let errorImportPath: string | undefined
    if (errorImportPathRaw) {
      const [modulePath, className] = errorImportPathRaw.split('#')
      if (!(modulePath && className)) {
        throw new Error(
          `Invalid errorImportPath format: "${errorImportPathRaw}". Expected "path/to/module#ErrorClassName"`,
        )
      }

      if (modulePath.startsWith('.')) {
        const absoluteErrorPath = path.resolve(schemaDir, modulePath)
        const relativeToOutput = path.relative(outputDir, absoluteErrorPath)
        const normalizedPath = relativeToOutput.startsWith('.') ? relativeToOutput : `./${relativeToOutput}`
        const pathWithExtension = addExtension(normalizedPath)
        errorImportPath = `${pathWithExtension}#${className}`
      } else {
        errorImportPath = errorImportPathRaw
      }
    }

    // Clean output directory
    // await fs.rm(outputDir, { recursive: true, force: true })
    await fs.mkdir(outputDir, { recursive: true })

    // Write static files
    await fs.writeFile(path.join(outputDir, 'prisma-schema.ts'), prismaSchemaContent)
    await fs.writeFile(path.join(outputDir, 'prisma-repository.ts'), getPrismaModelContent(clientImportPath))

    // Generate unified index file with PrismaService
    await generateUnifiedService([...models], outputDir, clientImportPath, errorImportPath)

    // Fix imports in schemas/index.ts
    await fixSchemaImports(outputDir)
  },
})

async function fixSchemaImports(outputDir: string) {
  const schemasDir = path.join(outputDir, 'schemas')
  const indexFile = path.join(schemasDir, 'index.ts')

  try {
    const content = await fs.readFile(indexFile, 'utf-8')
    const fixedContent = content
      .replace(/export \* from '\.\/enums'/g, "export * from './enums.js'")
      .replace(/export \* from '\.\/types'/g, "export * from './types.js'")

    if (content !== fixedContent) {
      await fs.writeFile(indexFile, fixedContent)
    }
  } catch (_error) {
    // Ignore if file doesn't exist
  }
}

type CustomErrorConfig = { path: string; className: string } | null

function generateRawSqlOperations(customError: CustomErrorConfig) {
  const errorType = customError ? customError.className : 'PrismaError'

  return `
    $executeRaw: (args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]): Effect.Effect<number, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => mapError(error, "$executeRaw", "Prisma")
        })
      ),

    $executeRawUnsafe: (query: string, ...values: any[]): Effect.Effect<number, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
        })
      ),

    $queryRaw: <T = unknown>(args: PrismaNamespace.Sql | [PrismaNamespace.Sql, ...any[]]): Effect.Effect<T, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)) as Promise<T>,
          catch: (error) => mapError(error, "$queryRaw", "Prisma")
        })
      ),

    $queryRawUnsafe: <T = unknown>(query: string, ...values: any[]): Effect.Effect<T, ${errorType}, PrismaClient> =>
      Effect.flatMap(PrismaClient, ({ tx: client }) =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values) as Promise<T>,
          catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
        })
      ),`
}

function generateModelClasses(models: DMMF.Model[]) {
  const modelClasses = models
    .map((model) => {
      const modelName = model.name
      const className = `${modelName}Model`
      return `export class ${className} extends Model.Class<${className}>("${modelName}")({
  ..._${modelName}.fields
}) {}`
    })
    .join('\n\n')

  return modelClasses
}

// Parse error import path like "./errors#PrismaError" into { path, className }
function parseErrorImportPath(errorImportPath: string | undefined): { path: string; className: string } | null {
  if (!errorImportPath) {
    return null
  }
  const [path, className] = errorImportPath.split('#')
  if (!(path && className)) {
    throw new Error(`Invalid errorImportPath format: "${errorImportPath}". Expected "path/to/module#ErrorClassName"`)
  }
  return { path, className }
}

async function generateUnifiedService(
  models: DMMF.Model[],
  outputDir: string,
  clientImportPath: string,
  errorImportPath: string | undefined,
) {
  const customError = parseErrorImportPath(errorImportPath)
  const rawSqlOperations = generateRawSqlOperations(customError)
  const modelClasses = generateModelClasses(models)

  // Generate different content based on whether custom error is configured
  const serviceContent = customError
    ? generateCustomErrorService(customError, clientImportPath, rawSqlOperations, modelClasses, models)
    : generateDefaultErrorService(clientImportPath, rawSqlOperations, modelClasses, models)

  await fs.writeFile(path.join(outputDir, 'index.ts'), serviceContent)
}

/**
 * Generate service with custom user-provided error class.
 */
function generateCustomErrorService(
  customError: { path: string; className: string },
  clientImportPath: string,
  rawSqlOperations: string,
  modelClasses: string,
  models: DMMF.Model[],
): string {
  const schemaImports = models.map((m) => `_${m.name}`).join(', ')

  return `${header}
import { Context, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"
import { ${customError.className}, mapPrismaError } from "${customError.path}"
import * as Model from "./prisma-repository.js"
import { ${schemaImports} } from "./schemas/index.js"

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

// Re-export the custom error type for convenience
export { ${customError.className} }

// Use the user-provided error mapper
const mapError = mapPrismaError

/**
 * Internal helper to begin a callback-free interactive transaction.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, ${customError.className}> =>
  Effect.async<FlatTransactionClient, ${customError.className}>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      if (e === ROLLBACK) return
      throw e
    })

    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | ${customError.className}, R> => {
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | ${customError.className}, R> => {
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      ${rawSqlOperations}
    }
  })
}) {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

export const PrismaClientService = PrismaClient
export const PrismaService = Prisma
export const makePrismaLayer = PrismaClient.layer
export const makePrismaLayerEffect = PrismaClient.layerEffect

${modelClasses}
`
}

/**
 * Generate service with default tagged error classes.
 */
function generateDefaultErrorService(
  clientImportPath: string,
  rawSqlOperations: string,
  modelClasses: string,
  models: DMMF.Model[],
): string {
  const schemaImports = models.map((m) => `_${m.name}`).join(', ')

  return `${header}
import { Context, Data, Effect, Exit, Layer } from "effect"
import { Service } from "effect/Effect"
import { Prisma as PrismaNamespace, PrismaClient as BasePrismaClient } from "${clientImportPath}"
import * as Model from "./prisma-repository.js"
import { ${schemaImports} } from "./schemas/index.js"

// Symbol used to identify intentional rollbacks vs actual errors
const ROLLBACK = Symbol.for("prisma.effect.rollback")

// Type for the flat transaction client with commit/rollback control
type FlatTransactionClient = PrismaNamespace.TransactionClient & {
  $commit: () => Promise<void>
  $rollback: () => Promise<void>
}

/** Transaction options for $transaction and $isolatedTransaction */
type TransactionOptions = {
  maxWait?: number
  timeout?: number
  isolationLevel?: PrismaNamespace.TransactionIsolationLevel
}

/**
 * Context tag for the Prisma client instance.
 * Holds the transaction client (tx) and root client.
 */
export class PrismaClient extends Context.Tag("PrismaClient")<
  PrismaClient,
  {
    tx: BasePrismaClient | PrismaNamespace.TransactionClient
    client: BasePrismaClient
  }
>() {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const prisma = new BasePrismaClient(...args)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.scoped(
    PrismaClient,
    Effect.gen(function* () {
      const options = yield* optionsEffect
      const prisma = new BasePrismaClient(options)
      yield* Effect.addFinalizer(() => Effect.promise(() => prisma.$disconnect()))
      return { tx: prisma, client: prisma }
    })
  )
}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: PrismaNamespace.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof PrismaNamespace.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

/**
 * Internal helper to begin a callback-free interactive transaction.
 */
const $begin = (
  client: BasePrismaClient,
  options?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: PrismaNamespace.TransactionIsolationLevel
  }
): Effect.Effect<FlatTransactionClient, PrismaError> =>
  Effect.async<FlatTransactionClient, PrismaError>((resume) => {
    let setTxClient: (txClient: PrismaNamespace.TransactionClient) => void
    let commit: () => void
    let rollback: () => void

    const txClientPromise = new Promise<PrismaNamespace.TransactionClient>((res) => {
      setTxClient = res
    })

    const txPromise = new Promise<void>((_res, _rej) => {
      commit = () => _res(undefined)
      rollback = () => _rej(ROLLBACK)
    })

    const tx = client.$transaction((txClient) => {
      setTxClient(txClient)
      return txPromise
    }, options).catch((e) => {
      if (e === ROLLBACK) return
      throw e
    })

    txClientPromise.then((innerTx) => {
      const proxy = new Proxy(innerTx, {
        get(target, prop) {
          if (prop === "$commit") return () => { commit(); return tx }
          if (prop === "$rollback") return () => { rollback(); return tx }
          return target[prop as keyof typeof target]
        },
      }) as FlatTransactionClient
      resume(Effect.succeed(proxy))
    }).catch((error) => {
      resume(Effect.fail(mapError(error, "$transaction", "Prisma")))
    })
  })

/**
 * The main Prisma service with all database operations.
 * Provides type-safe, effectful access to your Prisma models.
 */
export class Prisma extends Service<Prisma>()("Prisma", {
  effect: Effect.gen(function* () {
    return {
      $transaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client, tx }): Effect.Effect<A, E | PrismaError, R> => {
            const isRootClient = "$transaction" in tx
            if (!isRootClient) {
              return effect
            }

            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),

      $isolatedTransaction: <R, E, A>(
        effect: Effect.Effect<A, E, R>,
        options?: TransactionOptions
      ) =>
        Effect.flatMap(
          PrismaClient,
          ({ client }): Effect.Effect<A, E | PrismaError, R> => {
            return Effect.acquireUseRelease(
              $begin(client, options),
              (txClient) =>
                effect.pipe(
                  Effect.provideService(PrismaClient, { tx: txClient, client })
                ),
              (txClient, exit) =>
                Exit.isSuccess(exit)
                  ? Effect.promise(() => txClient.$commit())
                  : Effect.promise(() => txClient.$rollback())
            )
          }
        ),
      ${rawSqlOperations}
    }
  })
}) {
  static layer = (
    ...args: ConstructorParameters<typeof BasePrismaClient>
  ) => Layer.merge(PrismaClient.layer(...args), Prisma.Default)

  static layerEffect = <R, E>(
    optionsEffect: Effect.Effect<ConstructorParameters<typeof BasePrismaClient>[0], E, R>
  ) => Layer.merge(PrismaClient.layerEffect(optionsEffect), Prisma.Default)

}

// ============================================================================
// Deprecated aliases for backward compatibility
// ============================================================================

export const PrismaClientService = PrismaClient
export const PrismaService = Prisma
export const makePrismaLayer = PrismaClient.layer
export const makePrismaLayerEffect = PrismaClient.layerEffect

${modelClasses}
`
}
